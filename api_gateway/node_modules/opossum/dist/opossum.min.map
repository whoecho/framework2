{"version":3,"file":"opossum.min.js","mappings":"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","sources":["webpack://circuitBreaker/webpack/universalModuleDefinition","webpack://circuitBreaker/./index.js","webpack://circuitBreaker/./lib/circuit.js","webpack://circuitBreaker/./lib/semaphore.js","webpack://circuitBreaker/./lib/status.js","webpack://circuitBreaker/./node_modules/events/events.js","webpack://circuitBreaker/webpack/bootstrap","webpack://circuitBreaker/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"circuitBreaker\"] = factory();\n\telse\n\t\troot[\"circuitBreaker\"] = factory();\n})(self, () => {\nreturn ","'use strict';\n\nmodule.exports = exports = require('./lib/circuit');\n","'use strict';\n\nconst EventEmitter = require('events');\nconst Status = require('./status');\nconst Semaphore = require('./semaphore');\n\nconst STATE = Symbol('state');\nconst OPEN = Symbol('open');\nconst CLOSED = Symbol('closed');\nconst HALF_OPEN = Symbol('half-open');\nconst PENDING_CLOSE = Symbol('pending-close');\nconst SHUTDOWN = Symbol('shutdown');\nconst FALLBACK_FUNCTION = Symbol('fallback');\nconst STATUS = Symbol('status');\nconst NAME = Symbol('name');\nconst GROUP = Symbol('group');\nconst CACHE = new WeakMap();\nconst ENABLED = Symbol('Enabled');\nconst WARMING_UP = Symbol('warming-up');\nconst VOLUME_THRESHOLD = Symbol('volume-threshold');\nconst OUR_ERROR = Symbol('our-error');\nconst RESET_TIMEOUT = Symbol('reset-timeout');\nconst WARMUP_TIMEOUT = Symbol('warmup-timeout');\nconst LAST_TIMER_AT = Symbol('last-timer-at');\nconst deprecation = `options.maxFailures is deprecated. \\\nPlease use options.errorThresholdPercentage`;\n\n/**\n * Constructs a {@link CircuitBreaker}.\n *\n * @class CircuitBreaker\n * @extends EventEmitter\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Status} options.status A {@link Status} object that might\n *   have pre-prime stats\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Timeout can be disabled by setting\n * this to `false`. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000/1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: true\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountTimeout` property). Default: false\n * This can help in situations where no matter what your\n * `errorThresholdPercentage` is, if the first execution times out or fails,\n * the circuit immediately opens.\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failPure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n * @param {boolean} options.cache whether the return value of the first\n * successful execution of the circuit's function will be cached. Once a value\n * has been cached that value will be returned for every subsequent execution:\n * the cache can be cleared using `clearCache`. (The metrics `cacheHit` and\n * `cacheMiss` reflect cache activity.) Default: false\n * @param {AbortController} options.abortController this allows Opossum to\n * signal upon timeout and properly abort your on going requests instead of\n * leaving it in the background\n *\n *\n * @fires CircuitBreaker#halfOpen\n * @fires CircuitBreaker#close\n * @fires CircuitBreaker#open\n * @fires CircuitBreaker#fire\n * @fires CircuitBreaker#cacheHit\n * @fires CircuitBreaker#cacheMiss\n * @fires CircuitBreaker#reject\n * @fires CircuitBreaker#timeout\n * @fires CircuitBreaker#success\n * @fires CircuitBreaker#semaphoreLocked\n * @fires CircuitBreaker#healthCheckFailed\n * @fires CircuitBreaker#fallback\n * @fires CircuitBreaker#failure\n */\nclass CircuitBreaker extends EventEmitter {\n  /**\n   * Returns true if the provided error was generated here. It will be false\n   * if the error came from the action itself.\n   * @param {Error} error The Error to check.\n   * @returns {Boolean} true if the error was generated here\n   */\n  static isOurError (error) {\n    return !!error[OUR_ERROR];\n  }\n\n  /**\n  * Create a new Status object,\n  * helpful when you need to prime a breaker with stats\n  * @param {Object} options -\n  * @param {Number} options.rollingCountBuckets number of buckets in the window\n  * @param {Number} options.rollingCountTimeout the duration of the window\n  * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n  * @param {Object} options.stats user supplied stats\n  * @returns {Status} a new {@link Status} object\n  */\n  static newStatus (options) {\n    return new Status(options);\n  }\n\n  constructor (action, options = {}) {\n    super();\n    this.options = options;\n    this.options.timeout =\n      options.timeout === false ? false : options.timeout || 10000;\n    this.options.resetTimeout = options.resetTimeout || 30000;\n    this.options.errorThresholdPercentage =\n      options.errorThresholdPercentage || 50;\n    this.options.rollingCountTimeout = options.rollingCountTimeout || 10000;\n    this.options.rollingCountBuckets = options.rollingCountBuckets || 10;\n    this.options.rollingPercentilesEnabled =\n      options.rollingPercentilesEnabled !== false;\n    this.options.capacity = Number.isInteger(options.capacity)\n      ? options.capacity\n      : Number.MAX_SAFE_INTEGER;\n    this.options.errorFilter = options.errorFilter || (_ => false);\n\n    this.semaphore = new Semaphore(this.options.capacity);\n\n    // check if action is defined\n    if (!action) {\n      throw new TypeError(\n        'No action provided. Cannot construct a CircuitBreaker without an invocable action.'\n      );\n    }\n\n    if (options.abortController && typeof options.abortController.abort !== 'function') {\n      throw new TypeError(\n        'AbortController does not contain `abort()` method'\n      );\n    }\n\n    this[VOLUME_THRESHOLD] = Number.isInteger(options.volumeThreshold)\n      ? options.volumeThreshold\n      : 0;\n    this[WARMING_UP] = options.allowWarmUp === true;\n\n    // The user can pass in a Status object to initialize the Status/stats\n    if (this.options.status) {\n      // Do a check that this is a Status Object,\n      if (this.options.status instanceof Status) {\n        this[STATUS] = this.options.status;\n      } else {\n        this[STATUS] = new Status({ stats: this.options.status });\n      }\n    } else {\n      this[STATUS] = new Status(this.options);\n    }\n\n    this[STATE] = CLOSED;\n\n    if (options.state) {\n      this[ENABLED] = options.state.enabled !== false;\n      this[WARMING_UP] = options.state.warmUp || this[WARMING_UP];\n      // Closed if nothing is passed in\n      this[CLOSED] = options.state.closed !== false;\n      // These should be in sync\n      this[HALF_OPEN] = this[PENDING_CLOSE] = options.state.halfOpen || false;\n      // Open should be the opposite of closed,\n      // but also the opposite of half_open\n      this[OPEN] = !this[CLOSED] && !this[HALF_OPEN];\n      this[SHUTDOWN] = options.state.shutdown || false;\n    } else {\n      this[PENDING_CLOSE] = false;\n      this[ENABLED] = options.enabled !== false;\n    }\n\n    this[FALLBACK_FUNCTION] = null;\n    this[NAME] = options.name || action.name || nextName();\n    this[GROUP] = options.group || this[NAME];\n\n    if (this[WARMING_UP]) {\n      const timer = this[WARMUP_TIMEOUT] = setTimeout(\n        _ => (this[WARMING_UP] = false),\n        this.options.rollingCountTimeout\n      );\n      if (typeof timer.unref === 'function') {\n        timer.unref();\n      }\n    }\n\n    if (typeof action !== 'function') {\n      this.action = _ => Promise.resolve(action);\n    } else this.action = action;\n\n    if (options.maxFailures) console.error(deprecation);\n\n    const increment = property =>\n      (result, runTime) => this[STATUS].increment(property, runTime);\n\n    this.on('success', increment('successes'));\n    this.on('failure', increment('failures'));\n    this.on('fallback', increment('fallbacks'));\n    this.on('timeout', increment('timeouts'));\n    this.on('fire', increment('fires'));\n    this.on('reject', increment('rejects'));\n    this.on('cacheHit', increment('cacheHits'));\n    this.on('cacheMiss', increment('cacheMisses'));\n    this.on('open', _ => this[STATUS].open());\n    this.on('close', _ => this[STATUS].close());\n    this.on('semaphoreLocked', increment('semaphoreRejections'));\n\n    /**\n     * @param {CircuitBreaker} circuit This current circuit\n     * @returns {function(): void} A bound reset callback\n     * @private\n     */\n    function _startTimer (circuit) {\n      circuit[LAST_TIMER_AT] = Date.now();\n      return _ => {\n        const timer = circuit[RESET_TIMEOUT] = setTimeout(() => {\n          _halfOpen(circuit);\n        }, circuit.options.resetTimeout);\n        if (typeof timer.unref === 'function') {\n          timer.unref();\n        }\n      };\n    }\n\n    /**\n     * Sets the circuit breaker to half open\n     * @private\n     * @param {CircuitBreaker} circuit The current circuit breaker\n     * @returns {void}\n     */\n    function _halfOpen (circuit) {\n      circuit[STATE] = HALF_OPEN;\n      circuit[PENDING_CLOSE] = true;\n      /**\n       * Emitted after `options.resetTimeout` has elapsed, allowing for\n       * a single attempt to call the service again. If that attempt is\n       * successful, the circuit will be closed. Otherwise it remains open.\n       *\n       * @event CircuitBreaker#halfOpen\n       * @type {Number} how long the circuit remained open\n       */\n      circuit.emit('halfOpen', circuit.options.resetTimeout);\n    }\n\n    this.on('open', _startTimer(this));\n    this.on('success', _ => {\n      if (this.halfOpen) {\n        this.close();\n      }\n    });\n    if (this.options.cache) {\n      CACHE.set(this, undefined);\n    }\n\n    // Prepopulate the State of the Breaker\n    if (this[SHUTDOWN]) {\n      this[STATE] = SHUTDOWN;\n      this.shutdown();\n    } else if (this[CLOSED]) {\n      this.close();\n    } else if (this[OPEN]) {\n      // If the state being passed in is OPEN but more time has elapsed\n      // than the resetTimeout, then we should be in halfOpen state\n      if (this.options.state.lastTimerAt !== undefined &&\n        (Date.now() - this.options.state.lastTimerAt) >\n        this.options.resetTimeout) {\n        _halfOpen(this);\n      } else {\n        this.open();\n      }\n    } else if (this[HALF_OPEN]) {\n      // Not sure if anything needs to be done here\n      this[STATE] = HALF_OPEN;\n    }\n  }\n\n  /**\n   * Closes the breaker, allowing the action to execute again\n   * @fires CircuitBreaker#close\n   * @returns {void}\n   */\n  close () {\n    if (this[STATE] !== CLOSED) {\n      if (this[RESET_TIMEOUT]) {\n        clearTimeout(this[RESET_TIMEOUT]);\n      }\n      this[STATE] = CLOSED;\n      this[PENDING_CLOSE] = false;\n      /**\n       * Emitted when the breaker is reset allowing the action to execute again\n       * @event CircuitBreaker#close\n       */\n      this.emit('close');\n    }\n  }\n\n  /**\n   * Opens the breaker. Each time the breaker is fired while the circuit is\n   * opened, a failed Promise is returned, or if any fallback function\n   * has been provided, it is invoked.\n   *\n   * If the breaker is already open this call does nothing.\n   * @fires CircuitBreaker#open\n   * @returns {void}\n   */\n  open () {\n    if (this[STATE] !== OPEN) {\n      this[STATE] = OPEN;\n      this[PENDING_CLOSE] = false;\n      /**\n       * Emitted when the breaker opens because the action has\n       * failure percentage greater than `options.errorThresholdPercentage`.\n       * @event CircuitBreaker#open\n       */\n      this.emit('open');\n    }\n  }\n\n  /**\n   * Shuts down this circuit breaker. All subsequent calls to the\n   * circuit will fail, returning a rejected promise.\n   * @returns {void}\n   */\n  shutdown () {\n    /**\n     * Emitted when the circuit breaker has been shut down.\n     * @event CircuitBreaker#shutdown\n     */\n    this.emit('shutdown');\n\n    this.disable();\n    this.removeAllListeners();\n    if (this[RESET_TIMEOUT]) {\n      clearTimeout(this[RESET_TIMEOUT]);\n    }\n    if (this[WARMUP_TIMEOUT]) {\n      clearTimeout(this[WARMUP_TIMEOUT]);\n    }\n    this.status.shutdown();\n    this[STATE] = SHUTDOWN;\n  }\n\n  /**\n   * Determines if the circuit has been shutdown.\n   * @type {Boolean}\n   */\n  get isShutdown () {\n    return this[STATE] === SHUTDOWN;\n  }\n\n  /**\n   * Gets the name of this circuit\n   * @type {String}\n   */\n  get name () {\n    return this[NAME];\n  }\n\n  /**\n   * Gets the name of this circuit group\n   * @type {String}\n   */\n  get group () {\n    return this[GROUP];\n  }\n\n  /**\n   * Gets whether this circuit is in the `pendingClosed` state\n   * @type {Boolean}\n   */\n  get pendingClose () {\n    return this[PENDING_CLOSE];\n  }\n\n  /**\n   * True if the circuit is currently closed. False otherwise.\n   * @type {Boolean}\n   */\n  get closed () {\n    return this[STATE] === CLOSED;\n  }\n\n  /**\n   * True if the circuit is currently opened. False otherwise.\n   * @type {Boolean}\n   */\n  get opened () {\n    return this[STATE] === OPEN;\n  }\n\n  /**\n   * True if the circuit is currently half opened. False otherwise.\n   * @type {Boolean}\n   */\n  get halfOpen () {\n    return this[STATE] === HALF_OPEN;\n  }\n\n  /**\n   * The current {@link Status} of this {@link CircuitBreaker}\n   * @type {Status}\n   */\n  get status () {\n    return this[STATUS];\n  }\n\n  /**\n   * Get the current stats for the circuit.\n   * @see Status#stats\n   * @type {Object}\n   */\n  get stats () {\n    return this[STATUS].stats;\n  }\n\n  toJSON () {\n    return {\n      state: {\n        name: this.name,\n        enabled: this.enabled,\n        closed: this.closed,\n        open: this.opened,\n        halfOpen: this.halfOpen,\n        warmUp: this.warmUp,\n        shutdown: this.isShutdown,\n        lastTimerAt: this[LAST_TIMER_AT]\n      },\n      status: this.status.stats\n    };\n  }\n\n  /**\n   * Gets whether the circuit is enabled or not\n   * @type {Boolean}\n   */\n  get enabled () {\n    return this[ENABLED];\n  }\n\n  /**\n   * Gets whether the circuit is currently in warm up phase\n   * @type {Boolean}\n   */\n  get warmUp () {\n    return this[WARMING_UP];\n  }\n\n  /**\n   * Gets the volume threshold for this circuit\n   * @type {Boolean}\n   */\n  get volumeThreshold () {\n    return this[VOLUME_THRESHOLD];\n  }\n\n  /**\n   * Provide a fallback function for this {@link CircuitBreaker}. This\n   * function will be executed when the circuit is `fire`d and fails.\n   * It will always be preceded by a `failure` event, and `breaker.fire` returns\n   * a rejected Promise.\n   * @param {Function | CircuitBreaker} func the fallback function to execute\n   * when the breaker has opened or when a timeout or error occurs.\n   * @return {CircuitBreaker} this\n   */\n  fallback (func) {\n    let fb = func;\n    if (func instanceof CircuitBreaker) {\n      fb = function () {\n        return func.fire.apply(func, arguments);\n      };\n    }\n    this[FALLBACK_FUNCTION] = fb;\n    return this;\n  }\n\n  /**\n   * Execute the action for this circuit. If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * Any parameters passed to this function will be proxied to the circuit\n   * function.\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action. Use isOurError()\n   * to determine if a rejection was a result of the circuit breaker or the\n   * action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n  fire (...args) {\n    return this.call.apply(this, [this.action].concat(args));\n  }\n\n  /**\n   * Execute the action for this circuit using `context` as `this`.\n   * If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * Any parameters in addition to `context will be passed to the\n   * circuit function.\n   *\n   * @param {any} context the `this` context used for function execution\n   * @param {any} rest the arguments passed to the action\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n  call (context, ...rest) {\n    if (this.isShutdown) {\n      const err = buildError('The circuit has been shutdown.', 'ESHUTDOWN');\n      return Promise.reject(err);\n    }\n    const args = Array.prototype.slice.call(rest);\n\n    /**\n     * Emitted when the circuit breaker action is executed\n     * @event CircuitBreaker#fire\n     * @type {any} the arguments passed to the fired function\n     */\n    this.emit('fire', args);\n\n    if (CACHE.get(this) !== undefined) {\n      /**\n       * Emitted when the circuit breaker is using the cache\n       * and finds a value.\n       * @event CircuitBreaker#cacheHit\n       */\n      this.emit('cacheHit');\n      return CACHE.get(this);\n    } else if (this.options.cache) {\n      /**\n       * Emitted when the circuit breaker does not find a value in\n       * the cache, but the cache option is enabled.\n       * @event CircuitBreaker#cacheMiss\n       */\n      this.emit('cacheMiss');\n    }\n\n    if (!this[ENABLED]) {\n      const result = this.action.apply(context, args);\n      return (typeof result.then === 'function')\n        ? result\n        : Promise.resolve(result);\n    }\n\n    if (!this.closed && !this.pendingClose) {\n      /**\n       * Emitted when the circuit breaker is open and failing fast\n       * @event CircuitBreaker#reject\n       * @type {Error}\n       */\n      const error = buildError('Breaker is open', 'EOPENBREAKER');\n\n      this.emit('reject', error);\n\n      return fallback(this, error, args) ||\n        Promise.reject(error);\n    }\n    this[PENDING_CLOSE] = false;\n\n    let timeout;\n    let timeoutError = false;\n    return new Promise((resolve, reject) => {\n      const latencyStartTime = Date.now();\n      if (this.semaphore.test()) {\n        if (this.options.timeout) {\n          timeout = setTimeout(\n            () => {\n              timeoutError = true;\n              const error = buildError(\n                `Timed out after ${this.options.timeout}ms`, 'ETIMEDOUT'\n              );\n              const latency = Date.now() - latencyStartTime;\n              this.semaphore.release();\n              /**\n               * Emitted when the circuit breaker action takes longer than\n               * `options.timeout`\n               * @event CircuitBreaker#timeout\n               * @type {Error}\n               */\n              this.emit('timeout', error, latency, args);\n              handleError(error, this, timeout, args, latency, resolve, reject);\n              if (this.options.abortController) {\n                this.options.abortController.abort();\n              }\n            }, this.options.timeout);\n        }\n\n        try {\n          const result = this.action.apply(context, args);\n          const promise = (typeof result.then === 'function')\n            ? result\n            : Promise.resolve(result);\n\n          promise.then(result => {\n            if (!timeoutError) {\n              clearTimeout(timeout);\n              /**\n               * Emitted when the circuit breaker action succeeds\n               * @event CircuitBreaker#success\n               * @type {any} the return value from the circuit\n               */\n              this.emit('success', result, (Date.now() - latencyStartTime));\n              this.semaphore.release();\n              resolve(result);\n              if (this.options.cache) {\n                CACHE.set(this, promise);\n              }\n            }\n          })\n            .catch(error => {\n              if (!timeoutError) {\n                this.semaphore.release();\n                const latencyEndTime = Date.now() - latencyStartTime;\n                handleError(\n                  error, this, timeout, args, latencyEndTime, resolve, reject);\n              }\n            });\n        } catch (error) {\n          this.semaphore.release();\n          const latency = Date.now() - latencyStartTime;\n          handleError(error, this, timeout, args, latency, resolve, reject);\n        }\n      } else {\n        const latency = Date.now() - latencyStartTime;\n        const err = buildError('Semaphore locked', 'ESEMLOCKED');\n        /**\n         * Emitted when the rate limit has been reached and there\n         * are no more locks to be obtained.\n         * @event CircuitBreaker#semaphoreLocked\n         * @type {Error}\n         */\n        this.emit('semaphoreLocked', err, latency);\n        handleError(err, this, timeout, args, latency, resolve, reject);\n      }\n    });\n  }\n\n  /**\n   * Clears the cache of this {@link CircuitBreaker}\n   * @returns {void}\n   */\n  clearCache () {\n    CACHE.set(this, undefined);\n  }\n\n  /**\n   * Provide a health check function to be called periodically. The function\n   * should return a Promise. If the promise is rejected the circuit will open.\n   * This is in addition to the existing circuit behavior as defined by\n   * `options.errorThresholdPercentage` in the constructor. For example, if the\n   * health check function provided here always returns a resolved promise, the\n   * circuit can still trip and open if there are failures exceeding the\n   * configured threshold. The health check function is executed within the\n   * circuit breaker's execution context, so `this` within the function is the\n   * circuit breaker itself.\n   *\n   * @param {Function} func a health check function which returns a promise.\n   * @param {Number} [interval] the amount of time between calls to the health\n   * check function. Default: 5000 (5 seconds)\n   *\n   * @returns {void}\n   *\n   * @fires CircuitBreaker#healthCheckFailed\n   * @throws {TypeError} if `interval` is supplied but not a number\n   */\n  healthCheck (func, interval) {\n    interval = interval || 5000;\n    if (typeof func !== 'function') {\n      throw new TypeError('Health check function must be a function');\n    }\n    if (isNaN(interval)) {\n      throw new TypeError('Health check interval must be a number');\n    }\n\n    const check = _ => {\n      func.apply(this).catch(e => {\n        /**\n         * Emitted with the user-supplied health check function\n         * returns a rejected promise.\n         * @event CircuitBreaker#healthCheckFailed\n         * @type {Error}\n         */\n        this.emit('healthCheckFailed', e);\n        this.open();\n      });\n    };\n\n    const timer = setInterval(check, interval);\n    if (typeof timer.unref === 'function') {\n      timer.unref();\n    }\n\n    check();\n  }\n\n  /**\n   * Enables this circuit. If the circuit is the  disabled\n   * state, it will be re-enabled. If not, this is essentially\n   * a noop.\n   * @returns {void}\n   */\n  enable () {\n    this[ENABLED] = true;\n  }\n\n  /**\n   * Disables this circuit, causing all calls to the circuit's function\n   * to be executed without circuit or fallback protection.\n   * @returns {void}\n   */\n  disable () {\n    this[ENABLED] = false;\n  }\n}\n\nfunction handleError (error, circuit, timeout, args, latency, resolve, reject) {\n  clearTimeout(timeout);\n\n  if (circuit.options.errorFilter(error, ...args)) {\n    // The error was filtered, so emit 'success'\n    circuit.emit('success', error, latency);\n  } else {\n    // Error was not filtered, so emit 'failure'\n    fail(circuit, error, args, latency);\n\n    // Only call the fallback function if errorFilter doesn't succeed\n    // If the fallback function succeeds, resolve\n    const fb = fallback(circuit, error, args);\n    if (fb) return resolve(fb);\n  }\n  // In all other cases, reject\n  reject(error);\n}\n\nfunction fallback (circuit, err, args) {\n  if (circuit[FALLBACK_FUNCTION]) {\n    try {\n      const result =\n      circuit[FALLBACK_FUNCTION]\n        .apply(circuit[FALLBACK_FUNCTION], [...args, err]);\n      /**\n       * Emitted when the circuit breaker executes a fallback function\n       * @event CircuitBreaker#fallback\n       * @type {any} the return value of the fallback function\n       */\n      circuit.emit('fallback', result, err);\n      if (result instanceof Promise) return result;\n      return Promise.resolve(result);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\n\nfunction fail (circuit, err, args, latency) {\n  /**\n   * Emitted when the circuit breaker action fails\n   * @event CircuitBreaker#failure\n   * @type {Error}\n   */\n  circuit.emit('failure', err, latency, args);\n  if (circuit.warmUp) return;\n\n  // check stats to see if the circuit should be opened\n  const stats = circuit.stats;\n  if ((stats.fires < circuit.volumeThreshold) && !circuit.halfOpen) return;\n  const errorRate = stats.failures / stats.fires * 100;\n  if (errorRate > circuit.options.errorThresholdPercentage ||\n    circuit.halfOpen) {\n    circuit.open();\n  }\n}\n\nfunction buildError (msg, code) {\n  const error = new Error(msg);\n  error.code = code;\n  error[OUR_ERROR] = true;\n  return error;\n}\n\n// http://stackoverflow.com/a/2117523\nconst nextName = () =>\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n\nmodule.exports = exports = CircuitBreaker;\n","'use strict';\n\nmodule.exports = exports = semaphore;\n\nfunction semaphore (count) {\n  const resolvers = [];\n  let counter = count;\n\n  const sem = {\n    take,\n    release,\n    test\n  };\n\n  Object.defineProperty(sem, 'count', {\n    get: _ => counter,\n    enumerable: true\n  });\n\n  return sem;\n\n  function take (timeout) {\n    if (counter > 0) {\n      --counter;\n      return Promise.resolve(release);\n    }\n    return new Promise((resolve, reject) => {\n      resolvers.push(_ => {\n        --counter;\n        resolve(release);\n      });\n      if (timeout) {\n        setTimeout(_ => {\n          resolvers.shift();\n          const err = new Error(`Timed out after ${timeout}ms`);\n          err.code = 'ETIMEDOUT';\n          reject(err);\n        }, timeout);\n      }\n    });\n  }\n\n  function release () {\n    counter++;\n    if (resolvers.length > 0) {\n      resolvers.shift()();\n    }\n  }\n\n  function test () {\n    if (counter < 1) return false;\n    return take() && true;\n  }\n}\n","'use strict';\n\nconst WINDOW = Symbol('window');\nconst BUCKETS = Symbol('buckets');\nconst TIMEOUT = Symbol('timeout');\nconst PERCENTILES = Symbol('percentiles');\nconst BUCKET_INTERVAL = Symbol('bucket-interval');\nconst SNAPSHOT_INTERVAL = Symbol('snapshot-interval');\n\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Tracks execution status for a given {@link CircuitBreaker}.\n * A Status instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A Status instance will listen for all events on the {@link CircuitBreaker}\n * and track them in a rolling statistical window. The window duration is\n * determined by the `rollingCountTimeout` option provided to the\n * {@link CircuitBreaker}. The window consists of an array of Objects,\n * each representing the counts for a {@link CircuitBreaker}'s events.\n *\n * The array's length is determined by the {@link CircuitBreaker}'s\n * `rollingCountBuckets` option. The duration of each slice of the window\n * is determined by dividing the `rollingCountTimeout` by\n * `rollingCountBuckets`.\n *\n * @class Status\n * @extends EventEmitter\n * @param {Object} options for the status window\n * @param {Number} options.rollingCountBuckets number of buckets in the window\n * @param {Number} options.rollingCountTimeout the duration of the window\n * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n * percentiles\n * @param {Object} options.stats object of previous stats\n * @example\n * // Creates a 1 second window consisting of ten time slices,\n * // each 100ms long.\n * const circuit = circuitBreaker(fs.readFile,\n *  { rollingCountBuckets: 10, rollingCountTimeout: 1000});\n *\n * // get the cumulative statistics for the last second\n * circuit.status.stats;\n *\n * // get the array of 10, 1 second time slices for the last second\n * circuit.status.window;\n * @fires Status#snapshot\n * @see CircuitBreaker#status\n */\nclass Status extends EventEmitter {\n  constructor (options) {\n    super();\n\n    // Set up our statistical rolling window\n    this[BUCKETS] = options.rollingCountBuckets || 10;\n    this[TIMEOUT] = options.rollingCountTimeout || 10000;\n    this[WINDOW] = new Array(this[BUCKETS]);\n    this[PERCENTILES] = [0.0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.995, 1];\n\n    // Default this value to true\n    this.rollingPercentilesEnabled =\n    options.rollingPercentilesEnabled !== false;\n\n    // prime the window with buckets\n    for (let i = 0; i < this[BUCKETS]; i++) this[WINDOW][i] = bucket();\n\n    // rotate the buckets periodically\n    const bucketInterval = Math.floor(this[TIMEOUT] / this[BUCKETS]);\n    this[BUCKET_INTERVAL] = setInterval(nextBucket(this[WINDOW]),\n      bucketInterval);\n\n    // No unref() in the browser\n    if (typeof this[BUCKET_INTERVAL].unref === 'function') {\n      this[BUCKET_INTERVAL].unref();\n    }\n\n    /**\n     * Emitted at each time-slice. Listeners for this\n     * event will receive a cumulative snapshot of the current status window.\n     * @event Status#snapshot\n     * @type {Object}\n     */\n    this[SNAPSHOT_INTERVAL] = setInterval(\n      _ => this.emit('snapshot', this.stats),\n      bucketInterval);\n    if (typeof this[SNAPSHOT_INTERVAL].unref === 'function') {\n      this[SNAPSHOT_INTERVAL].unref();\n    }\n\n    if (options.stats) {\n      this[WINDOW][0] = { ...bucket(), ...options.stats };\n    }\n  }\n\n  /**\n   * Get the cumulative stats for the current window\n   * @type {Object}\n   */\n  get stats () {\n    const totals = this[WINDOW].reduce((acc, val) => {\n      if (!val) { return acc; }\n      Object.keys(acc).forEach(key => {\n        if (key !== 'latencyTimes' && key !== 'percentiles') {\n          (acc[key] += val[key] || 0);\n        }\n      });\n\n      if (this.rollingPercentilesEnabled) {\n        acc.latencyTimes.push.apply(acc.latencyTimes, val.latencyTimes || []);\n      }\n      return acc;\n    }, bucket());\n\n    if (this.rollingPercentilesEnabled) {\n      // Sort the latencyTimes\n      totals.latencyTimes.sort((a, b) => a - b);\n\n      // Get the mean latency\n      // Mean = sum of all values in the array/length of array\n      if (totals.latencyTimes.length) {\n        totals.latencyMean =\n          (totals\n            .latencyTimes\n            .reduce((a, b) => a + b, 0)) / totals.latencyTimes.length;\n      } else {\n        totals.latencyMean = 0;\n      }\n\n      // Calculate Percentiles\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] =\n          calculatePercentile(percentile, totals.latencyTimes);\n      });\n    } else {\n      totals.latencyMean = -1;\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] = -1;\n      });\n    }\n\n    return totals;\n  }\n\n  /**\n   * Gets the stats window as an array of time-sliced objects.\n   * @type {Array}\n   */\n  get window () {\n    return this[WINDOW].slice();\n  }\n\n  increment (property, latencyRunTime) {\n    this[WINDOW][0][property]++;\n    if (property === 'successes' ||\n        property === 'failures' ||\n        property === 'timeouts') {\n      this[WINDOW][0].latencyTimes.push(latencyRunTime || 0);\n    }\n  }\n\n  open () {\n    this[WINDOW][0].isCircuitBreakerOpen = true;\n  }\n\n  close () {\n    this[WINDOW][0].isCircuitBreakerOpen = false;\n  }\n\n  shutdown () {\n    this.removeAllListeners();\n    clearInterval(this[BUCKET_INTERVAL]);\n    clearInterval(this[SNAPSHOT_INTERVAL]);\n  }\n}\n\nconst nextBucket = window => _ => {\n  window.pop();\n  window.unshift(bucket());\n};\n\nconst bucket = _ => ({\n  failures: 0,\n  fallbacks: 0,\n  successes: 0,\n  rejects: 0,\n  fires: 0,\n  timeouts: 0,\n  cacheHits: 0,\n  cacheMisses: 0,\n  semaphoreRejections: 0,\n  percentiles: {},\n  latencyTimes: []\n});\n\nfunction calculatePercentile (percentile, arr) {\n  if (percentile === 0) {\n    return arr[0] || 0;\n  }\n  const idx = Math.ceil(percentile * arr.length);\n  return arr[idx - 1] || 0;\n}\n\nmodule.exports = exports = Status;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(497);\n"],"names":["root","factory","exports","module","define","amd","self","require","EventEmitter","Status","Semaphore","STATE","Symbol","OPEN","CLOSED","HALF_OPEN","PENDING_CLOSE","SHUTDOWN","FALLBACK_FUNCTION","STATUS","NAME","GROUP","CACHE","WeakMap","ENABLED","WARMING_UP","VOLUME_THRESHOLD","OUR_ERROR","RESET_TIMEOUT","WARMUP_TIMEOUT","LAST_TIMER_AT","deprecation","CircuitBreaker","action","options","timeout","resetTimeout","errorThresholdPercentage","rollingCountTimeout","rollingCountBuckets","rollingPercentilesEnabled","capacity","Number","isInteger","MAX_SAFE_INTEGER","errorFilter","_","semaphore","TypeError","abortController","abort","volumeThreshold","allowWarmUp","status","stats","state","enabled","warmUp","closed","halfOpen","shutdown","name","nextName","group","timer","setTimeout","unref","Promise","resolve","maxFailures","console","error","increment","property","result","runTime","_startTimer","circuit","Date","now","_halfOpen","emit","on","open","close","cache","set","undefined","lastTimerAt","this","clearTimeout","disable","removeAllListeners","opened","isShutdown","func","fb","fire","apply","arguments","args","call","concat","context","err","buildError","reject","rest","Array","prototype","slice","get","then","pendingClose","fallback","timeoutError","latencyStartTime","test","latency","release","handleError","promise","latencyEndTime","interval","isNaN","check","e","setInterval","fires","failures","fail","msg","code","Error","replace","c","r","Math","random","toString","count","resolvers","counter","sem","take","Object","defineProperty","enumerable","push","shift","length","WINDOW","BUCKETS","TIMEOUT","PERCENTILES","BUCKET_INTERVAL","SNAPSHOT_INTERVAL","i","bucket","bucketInterval","floor","nextBucket","totals","reduce","acc","val","keys","forEach","key","latencyTimes","sort","a","b","latencyMean","percentile","percentiles","arr","ceil","calculatePercentile","latencyRunTime","isCircuitBreakerOpen","clearInterval","window","pop","unshift","fallbacks","successes","rejects","timeouts","cacheHits","cacheMisses","semaphoreRejections","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","value","init","once","emitter","errorListener","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","warned","w","String","warn","onceWrapper","fired","wrapFn","_onceWrap","wrapped","bind","_listeners","unwrap","evlistener","ret","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","message","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","index","spliceOne","off","rawListeners","eventNames","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}